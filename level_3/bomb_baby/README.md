Challenge Restated:
In this challenge, you start with 1 Mach bomb (M) and 1 Facula bomb (F). At any given point, you can create more Mach bombs, by adding the number of Facula bombs. Likewise, to increase the number of Facula bombs, you can add the number of Mach bombs. You always begin with 1 Mach bomb and 1 Facula bomb and are given how many bombs of each kind need to be created. The solution should be the number of times (steps) you needed to increase the number of bombs. If the required number of bombs is impossible, that should be returned.

Solution:
The problem is stated as if we are working up, creating bombs until we have reached our goal. This creates a search problem where at each step you have 2 options; to increase the Facula bombs or the Mach bombs. It can also be challenging to prune the search tree. For example, starting with F=1 and M=1, we could keep adding 1 to F until we reach our goal or a high enough number to realize this path won't work. This would leave many paths still to explore before trying a similar search with adding 2 each time (add F=1 to M=1, then keep adding M=2 to F). With a goal as high as $$10^50$$, it was necessary to either find an aggressive pruning method or to reframe the problem and the resulting algorithm.

We can think of this problem as starting at the goal number of bombs and working our way to 1 of each type of bomb. When working backwards, we only have 1 choice at each step. You must always subtract the smaller number from the larger one. For example, if you have F=10 and M=9, you must remove 9 bombs from F leaving you with F=1 and M=9. This procedure is repeated until there is 1 bomb of each type left or that outcome is no longer possible.

To reduce the number of iterations in the loop, we can determine how many times the smaller number fits into the larger number and complete those reductions in one step. For example, if F=15 and M=6, we will need to subtract 6 bombs twice from F (15 - 6 = 9, 9 - 6 = 3). This can be done in one iteration using 15 - 12. This optimization will hurt the run time when there is only one or few subtractions required at each iteration, but it can be particularly helpful in situations like F=99 and M=2, where the same subtraction needs to occur many times. The tradeoff of slowing down the fastest runs to speed up the slowest runs seems helpful in this situation where timing out is the biggest worry regarding run time.
